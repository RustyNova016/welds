require 'pry'

head = %Q|

// Warning this file was generated by `gen.rb`

#[cfg(any(feature = "mysql", feature = "sqlite", feature = "postgres"))]
use sqlx::encode::Encode;
#[cfg(any(feature = "mysql", feature = "sqlite", feature = "postgres"))]
use sqlx::types::Type;

#[cfg(feature = "sqlite")]
use super::sqlite::SqliteParam;
#[cfg(feature = "mssql")]
use super::mssql::MssqlParam;

#[cfg(feature = "postgres")]
use super::postgres::PostgresParam;

#[cfg(feature = "mysql")]
use super::mysql::MysqlParam;
|



def blocky(cfgs, structs, wheres)
  %Q|

#{cfgs}
pub trait Param: #{structs.join(" + ")} {}

#{cfgs}
impl<T> Param for T
 where
     #{wheres},
     for<'a> &'a T: Send,
 {}
  
 |
end

for_a_head = "for<'a> "

p = [
  ["sqlite"  ,true , ["'a", "Send","Encode<'a, sqlx::Sqlite>", "Type<sqlx::Sqlite>"]],
  ["postgres",true , ["'a", "Send","Encode<'a, sqlx::Postgres>", "Type<sqlx::Postgres>"]],
  ["mysql"   ,true , ["'a", "Send","Encode<'a, sqlx::MySql>", "Type<sqlx::MySql>"]],
  ["mssql"   ,false, ["MssqlParam"]],
]

cc = p.combination(1) + p.combination(2) + p.combination(3) + p.combination(4)

all = ["sqlite", "postgres", "mysql", "mssql"]

out_code = head

cc.each do |c| 

  enabled_list = c.map{|a| a[0] } 
  disabled_list = all - enabled_list
  
  enabled = enabled_list.map{|f| "feature = \"#{f}\""}
  disabled = disabled_list.map{|f| "not(feature = \"#{f}\")"}
  rules = enabled + disabled
  cfgs = "#[cfg(all(#{rules.join(", ")}))]"

  need_for = c.map{|a| a[1] }.any?
  
  wheres = []
  c.each{|a| wheres = wheres + a[2] }
  wheres = wheres.uniq.join(" + ")
  wheres = "T: " + wheres 
  if need_for 
    wheres = for_a_head + wheres
  end

  structs = enabled_list.map{|x| x.capitalize + "Param"}

  out_code = out_code + "\n" + blocky(cfgs, structs, wheres)

end



puts out_code
